#include <stdio.h>
#include <math.h>
#include <stdlib.h>

int M = 136, S = 128, I = 8e3, C = 799, Q, O, K, intNodeLimit;
double N; //changed to double in case size was problem
bool booMMPrint; // global variable to tell micromax to print debug
char L, *P;
signed char    w[] = {0, 1, 1, -1, 3, 3, 5, 9};
signed char          o[] = { -16, -15, -17, 0, 1, 16, 0, 1, 16, 15, 17, 0, 14, 18, 31, 33, 0,
                             7, -1, 6, 11, 8, 3, 6,
                             6, 4, 5, 7, 3, 5, 4, 6
                           };
char b[129],
     n[] = ".?+knbrq?*?KNBRQ",
           c[9]; //input buffer used by micromax



// Opening book variables (generated by excel)
//char charOB[6][5] = { {"e2e4"}, {"d2d4"}, {"e7e5"}, {"c7c5"}, {"d7d5"}, {"g8f6"} }; //5 long for the null terminator needed by chess engine
//int intOBMoveOptions[6] = {2, 0, 2, 0, 2, 0}; // for each spot in charOB, how many of the following moves are options from that spot
//int intOBNext[6] = {2, 4, 0, 0, 0, 0}; // spot in array to move to if you select that move



int microMax(int k, int q, int l, int e, int E, int z, int n) //rewritten as above two lines wont compile
{

  //Serial.print("microMax called, n = "); Serial.println(n);

  int j, r, m, v, d, h, i, F, G, s;
  char t, p, u, x, y, X, Y, H, B;

  q--;
  d = X = Y = 0;

  while (d++ < n ||                          //trying just the depth test
         z == 8 & K == I && (N < intNodeLimit & d < 98 ||
                             (K = X, L = Y & ~M, d = 2)))         // && is AND, || is OR
    // while(d++<n|z==8&N<1e4&d<98)                //try code from 3.2
  { x = B = X;
    h = Y & S;
    m = d > 1 ? -I : e;
    N++;
    /*if (booMMPrint) {
      if (fmod(N, 1.00) == 0) {
        Serial.println(N); // crashing on 2457
        }
      if (N == 2457) {
        Serial.println("About to crash");
      }
      }*/
    do {
      u = b[x];
      if (u & k)
      { r = p = u & 7;
        j = o[p + 16];
        while (r = p > 2 & r < 0 ? -r : -o[++j])
        { A:
          y = x; F = G = S;
          do {
            H = y = h ? Y ^ h : y + r;
            if (y & M)break;
            m = E - S && b[E] && y - E < 2 & E - y < 2 ? I : m; /* castling-on-Pawn-check bug fixed */
            if (p < 3 & y == E)H ^= 16;
            t = b[H]; if (t & k | p < 3 & !(y - x & 7) - !t)break;
            i = 99 * w[t & 7];
            m = i < 0 ? I : m;               /* castling-on-Pawn-check bug fixed */
            if (m >= l)goto C;

            if (s = d - (y != z))
            { v = p < 6 ? b[x + 8] - b[y + 8] : 0;
              b[G] = b[H] = b[x] = 0; b[y] = u | 32;
              if (!(G & M))b[F] = k + 6, v += 30;
              if (p < 3)
              { v -= 9 * ((x - 2 & M || b[x - 2] - u) +
                          (x + 2 & M || b[x + 2] - u) - 1);
                if (y + r + 1 & S)b[y] |= 7, i += C;
              }
              v = -microMax(24 - k, -l, m > q ? -m : -q, -e - v - i, F, y, s);
              if (K - I)
              { if (v + I && x == K & y == L & z == 8)
                { Q = -e - i; O = F;
                  if (b[y] - u & 7 && P - c > 5)b[y] -= c[4] & 3; /* under-promotions */
                  return l;
                } v = m;
              }
              b[G] = k + 6; b[F] = b[y] = 0; b[x] = u; b[H] = t;
              if (v > m)
                m = v, X = x, Y = y | S & F;
              if (h) {
                h = 0;
                goto A;
              }
            }
            if (x + r - y | u & 32 |
                p > 2 & (p - 3 | j - 7 ||
                         b[G = x + 3 ^ r >> 1 & 7] - k - 6
                         || b[G ^ 1] | b[G ^ 2])
               )t += p < 5;
            else F = y;
          } while (!t);
        }
      }
    } while ((x = x + 9 & ~M) - B);
C: if (m > I - M | m < M - I)d = 98;
    m = m + I ? m : -microMax(24 - k, -I, I, 0, S, S, 1);
  }
  return m += m < e;
}

void init()
{
    K = 8; while (K--)
      { b[K] = (b[K + 112] = o[K + 24] + 8) + 8; b[K + 16] = 18; b[K + 96] = 9;
        L = 8; while (L--)b[16 * L + K + 8] = (K - 4) * (K - 4) + (L - 3.5) * (L - 3.5);
      }
}

void print()
{
    int intJ;
    for (intJ = 0; intJ < 120; intJ++) //changed this to stop using N which is the node variable
      {
        if (intJ & 8 && (intJ += 7))
        {
          printf("\n");
        }
        else {
          printf(" %c" ,n[b[intJ] & 15]);
        }
      }
      printf("\n");
}

int main()
{
    int k, maxr;
    init();
    print();

    while(1)
    {
        k = 8;
        K = I;
        N = 0;

        char ch[4];

        printf("Enter Move: \n");
        gets(ch);
        c[0] = (int) ch[0];
        c[1] = (int) ch[1];
        c[2] = (int) ch[2];
        c[3] = (int) ch[3];

        if (*c - 10) //valued pointed to by c i.e. c[0]. So if c[0] is different from '\n' line feed. i.e. ALWAYS called unless a blank newline is sent
        {
          K = *c - 16 * c[1] + C;
          L = c[2] - 16 * c[3] + C;
          maxr = microMax(k, -I, I, Q, O, 8, 2);
          printf("My Move: \n", k);
          print();
          k ^= 24;
        }

        //printf("%d %d\n\n", K, I);
        K = I;
        if(K==I){
            maxr = microMax(k, -I, I, Q, O, 8, 2);
            printf("Computers Move : \n", k);
            k ^= 24;
            print();
        }
    }

    return 0;
}

